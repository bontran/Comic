The async keyword does two things: it enables the await keyword within that method, and it transforms the method into a state machine (similar to how the yield keyword transforms iterator blocks into state machines). Async methods should return Task or Task<T> when possible. It’s permissible for an async method to return void, but it’s not recommended because it’s very difficult to consume (or test) an async void method.

The task instance returned from an async method is managed by the state machine. The state machine will create the task instance to return, and will later complete that task.

An async method begins executing synchronously. It’s only when the async method reaches an await operator that the method may become asynchronous. The await operator takes a single argument, an “awaitable” such as a Task instance. First, the await operator will check the awaitable to see if it has already completed; if it has, the method continues (synchronously). If the awaitable isn’t yet complete, the await operator will “pause” the method and resume when the awaitable completes. The second thing the await operator does is retrieve any results from the awaitable, raising exceptions if the awaitable completed with an error.

The Task or Task<T> returned by the async method conceptually represents the execution of that method. The task will complete when the method completes. If the method returns a value, the task is completed with that value as its result. If the method throws an exception (and doesn’t catch it), then the task is completed with that exception.

There are two immediate lessons to draw from this brief overview. First, when testing the results of an asynchronous method, the important bit is the Task it returns. The async method uses its Task to report completion, results and exceptions. The second lesson is that the await operator has special behavior when its awaitable is already complete. I’ll discuss this later when considering asynchronous stubs.